"""
Chat API endpoint for the AI chatbot.
"""

import os
from fastapi import APIRouter, HTTPException, Depends, Request
from pydantic import BaseModel
from typing import Optional, List, Any
from datetime import datetime, timezone
from sqlalchemy.orm import Session
import logging
from limiter import limiter


from database import get_db
from db.conversations import (
    get_or_create_conversation,
    store_message,
    get_conversation_history,
    format_history_for_llm
)
from agents.main_agent import get_main_agent


logger = logging.getLogger("routes.chat")

router = APIRouter()

# Rate limiting
DEFAULT_RATE_LIMIT = "5/minute"
RATE_LIMIT = os.getenv("BACKEND_RATE_LIMIT", DEFAULT_RATE_LIMIT)

# Pydantic models
class ChatRequest(BaseModel):
    """Request model for chat endpoint."""
    message: str
    conversation_id: Optional[int] = None


class ChatResponse(BaseModel):
    """Response model for chat endpoint."""
    conversation_id: int
    response: str
    tool_calls: List[Any] = []
    skill_used: Optional[str] = None
    created_at: str  # Changed from datetime to ensure proper JSON serialization


@router.post("/{user_id}/chat", response_model=ChatResponse)
@limiter.limit(RATE_LIMIT)
async def chat(
    user_id: str,
    request: Request,
    chat_request: ChatRequest,
    db: Session = Depends(get_db)
):
    """
    Send a chat message and receive an AI response.

    The message is routed to the appropriate skill agent based on intent.

    Args:
        user_id: User ID from path
        request: FastAPI request object for rate limiting
        chat_request: Chat request with message and optional conversation_id
        db: Database session

    Returns:
        ChatResponse with AI response and metadata
    """
    try:
        # Validate message
        if not chat_request.message or not chat_request.message.strip():
            raise HTTPException(status_code=400, detail="Message cannot be empty")

        # Get or create conversation
        conversation = get_or_create_conversation(
            db=db,
            user_id=user_id,
            conversation_id=chat_request.conversation_id
        )

        logger.info(f"Chat request from user {user_id}, conversation {conversation.id}")

        # Get conversation history
        history_messages = get_conversation_history(
            db=db,
            conversation_id=conversation.id,
            user_id=user_id,
            limit=50
        )
        conversation_history = format_history_for_llm(history_messages)

        # Store user message
        store_message(
            db=db,
            conversation_id=conversation.id,
            user_id=user_id,
            role="user",
            content=chat_request.message,
            tool_calls=None,
            skill_used=None
        )

        # Process with main agent
        main_agent = get_main_agent()
        result = await main_agent.process_message(
            user_id=user_id,
            user_message=chat_request.message,
            conversation_history=conversation_history,
            db=db
        )

        # Store assistant response
        assistant_message = store_message(
            db=db,
            conversation_id=conversation.id,
            user_id=user_id,
            role="assistant",
            content=result.get("content", ""),
            tool_calls=result.get("tool_calls", []),
            skill_used=result.get("skill_used")
        )

        logger.info(f"Response generated by {result.get('skill_used')}")

        return ChatResponse(
            conversation_id=conversation.id,
            response=result.get("content", ""),
            tool_calls=result.get("tool_calls", []),
            skill_used=result.get("skill_used"),
            created_at=assistant_message.created_at.isoformat() if assistant_message.created_at else ""
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in chat endpoint: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"An error occurred while processing your message: {str(e)}"
        )


@router.get("/{user_id}/conversations")
async def get_conversations(
    user_id: str,
    limit: int = 10,
    db: Session = Depends(get_db)
):
    """Get list of conversations for a user."""
    from models import Conversation

    conversations = db.query(Conversation).filter(
        Conversation.user_id == user_id
    ).order_by(Conversation.updated_at.desc()).limit(limit).all()

    return [
        {
            "id": c.id,
            "user_id": c.user_id,
            "created_at": c.created_at.isoformat() if c.created_at else "",
            "updated_at": c.updated_at.isoformat() if c.updated_at else "",
            "message_count": len(c.messages) if c.messages else 0
        }
        for c in conversations
    ]


@router.get("/{user_id}/conversations/{conversation_id}")
async def get_conversation_detail(
    user_id: str,
    conversation_id: int,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """Get a conversation with its messages."""
    from db.conversations import get_conversation

    conversation = get_conversation(db, conversation_id, user_id)
    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")

    messages = get_conversation_history(db, conversation_id, user_id, limit)

    return {
        "id": conversation.id,
        "user_id": conversation.user_id,
        "created_at": conversation.created_at.isoformat() if conversation.created_at else "",
        "updated_at": conversation.updated_at.isoformat() if conversation.updated_at else "",
        "messages": [
            {
                "id": m.id,
                "role": m.role,
                "content": m.content,
                "skill_used": m.skill_used,
                "tool_calls": m.tool_calls,
                "created_at": m.created_at.isoformat() if m.created_at else ""
            }
            for m in messages
        ]
    }


@router.delete("/{user_id}/conversations/{conversation_id}")
async def delete_conversation_endpoint(
    user_id: str,
    conversation_id: int,
    db: Session = Depends(get_db)
):
    """Delete a conversation and all its messages."""
    from db.conversations import delete_conversation

    success = delete_conversation(db, conversation_id, user_id)
    if not success:
        raise HTTPException(status_code=404, detail="Conversation not found")

    return {"message": "Conversation deleted successfully"}
